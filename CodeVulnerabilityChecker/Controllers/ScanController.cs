using CodeVulnerabilityChecker.Models;
using CodeVulnerabilityChecker.Extensions;
using Microsoft.AspNet.Identity;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Web;
using System.Web.Mvc;
using System.Web.Script.Serialization;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Web.Security;

namespace CodeVulnerabilityChecker.Controllers
{
    public class ScanController : BaseController
    {

        // GET: Scan
        [HttpGet]
        public ActionResult Scanning()
        {
            string currUser = currentUserId();  
            var GetFile = db.UserFiles.FirstOrDefault(f => f.FileOwner == currUser);
            string fileOwnerName = db.Users.Find(GetFile.FileOwner).FullName;

            return View(new ContentViewModel()
            {
                SnippetId = GetFile.FileId,
                SnippetTitle = GetFile.FileName,
                SnippetOwner = fileOwnerName,
                SnippetDate = GetFile.FileDate,
                SnippetContent = ConvertByteToString(GetFile.FileContent)
            });
        }

        public ActionResult Results(ResultsViewModel model)
        {
            string currUser = currentUserId();
            var GetFile = db.UserFiles.FirstOrDefault(f => f.FileOwner == currUser);
            string fileOwnerName = db.Users.Find(GetFile.FileOwner).FullName;


            model.SnippetTitle = GetFile.FileName;
            model.SnippetOwner = fileOwnerName;
            model.SnippetDate = GetFile.FileDate;
            model.SnippetContent = ConvertByteToString(GetFile.FileContent);

            model.ResultSummaries = GetResults(model);
            model.ResultsCount = model.ResultSummaries.Count();

            if (model.ResultsCount == 0)
            {
                model.ResultsImpact = "NONE";
            }
            else if (model.ResultsCount >= 1 && model.ResultsCount < 3)
            {
                model.ResultsImpact = "LOW";
            }
            else if (model.ResultsCount >= 3 && model.ResultsCount < 5)
            {
                model.ResultsImpact = "MEDIUM";
            }
            else if (model.ResultsCount >= 5)
            {
                model.ResultsImpact = "HIGH";
            }
            else
            {
                model.ResultsImpact = "Couldn't Calcuate Impact";
            }

            return View(model);
        }

        /// <summary>
        /// Returns back to input menu page and removes the last file uploaded by the user.
        /// </summary>
        /// <returns></returns>
        public ActionResult EndScan()
        {
            string currUser = currentUserId();
            var fileToDelete = db.UserFiles.FirstOrDefault(f => f.FileOwner == currUser);

            if(fileToDelete == null)
            {
                this.AddNotification("Scan has ended but " + fileToDelete.FileName + " couldn't be removed as it does not exist. I don't know how you did this but it's ok, files are removed for your security and this one doesn't exist.", NotificationType.WARNING);
            }
            else
            {
                db.UserFiles.Remove(fileToDelete);
                db.SaveChanges();
                this.AddNotification("Scan has ended and " + fileToDelete.FileName + " has been deleted for your security, in case you included any sensitive information.", NotificationType.INFO);

            }

            return RedirectToAction("Scan", "Home");
        }


        public List<string> GetResults(ResultsViewModel inputModel)
        {
            //API is not going to be used, just hardcoded vulnerabilities taken from the API json
            //var result = Task.Run(async () => await GetJson()).ConfigureAwait(false).GetAwaiter().GetResult();

            //API is not going to be used, just hardcoded vulnerabilities taken from the API json
            //var jsonString = JsonConvert.SerializeObject(result);

            //Create dictionary to return final results
            List<string> ResultDictionary = new List<string>();

            //Fill a dictionary with each line in the snippet input by the user
            Dictionary<string, string> SnippetLines = FillLineDictionary(inputModel.SnippetContent);

            //Dictionary to hold vulnerabilities and their messages
            Dictionary<string, string> VulnerabilityDict = VulnerabilityDictionary();

            //Loop through each line in the dictionary checking each word against the vulnerability JSON.
            foreach (KeyValuePair<string, string> entry in SnippetLines)
            {
                //Stores all words in the current line by splitting each word from spaces, ";" or "."
                string[] currentLineWords = entry.Value.Split(new[] { ' ', ';', ','});

                //Loop through each word checking against possible vulnerabilities
                foreach (string word in currentLineWords)
                {

                    if (word.Contains("<script>") || word.Contains("</script>"))
                    {
                        string errorMessage = word + " may cause a possible vulnerability, but the details can not be found.";
                        string VulMessage = entry.Value + Environment.NewLine + VulnerabilityDict["<script>"] + Environment.NewLine + Environment.NewLine;
                        ResultDictionary.Add("Line " + entry.Key + ": " + VulMessage);
                    }

                    //Checks the keys in the dictionary of vulnerabilites against the current word in the code snippet
                    if (VulnerabilityDict.ContainsKey(word))
                    {
                        string errorMessage = word + " may cause a possible vulnerability, but the details can not be found.";
                        string VulMessage = entry.Value + Environment.NewLine + VulnerabilityDict[word] + Environment.NewLine + Environment.NewLine;
                        ResultDictionary.Add("Line " + entry.Key + ": " + VulMessage);
                    }

                }

            }
                       
            return ResultDictionary;

        }


        /// <summary>
        /// Initializes a dictionary that will be used to hold each line of an input code snipet (string)
        /// </summary>
        /// <param name="sourceString"></param>
        /// <returns></returns>
        public Dictionary<string, string> FillLineDictionary(string sourceString)
        {
            Dictionary<string, string> dictionary = new Dictionary<string, string>();

            string[] Lines = sourceString.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

            for(int i = 0; i < Lines.Length; i++)
            {
                int j = i + 1;
                dictionary.Add(j.ToString(), Lines[i]);
            }

            return dictionary;
        }


        /// <summary>
        /// Fills up a dictionary with hardcoded example "vulnerabilities". Information was taken from the API, but it's not highly accurate.
        /// </summary>
        /// <returns></returns>
        public Dictionary<string, string> VulnerabilityDictionary()
        {
            Dictionary<string, string> Vulnerabilities = new Dictionary<string, string>();

            Vulnerabilities.Add("System.Web", "A denial of service vulnerability exists when the ASP.NET Core fails to properly validate web requests. NOTE: Microsoft has not commented on third-party claims that the issue is that the TextEncoder.EncodeCore function in the System.Text.Encodings.Web package in ASP.NET Core Mvc before 1.0.4 and 1.1.x before 1.1.3 allows remote attackers to cause a denial of service by leveraging failure to properly calculate the length of 4-byte characters in the Unicode Non-Character range.");
            Vulnerabilities.Add("System.Net", "Multiple cross-site scripting (XSS) vulnerabilities in Microsoft ASP.NET (.Net) 1.0 and 1.1 to SP1 allow remote attackers to inject arbitrary HTML or web script via Unicode representations for ASCII fullwidth characters that are converted to normal ASCII characters, including \">\" and \"<\".");
            Vulnerabilities.Add("System.Web.Mvc", "A spoofing vulnerability exists when the ASP.NET Core fails to properly sanitize web requests.");
            Vulnerabilities.Add("System.IO.Pipelines", "A denial of service vulnerability exists when System.IO.Pipelines improperly handles requests, aka \"System.IO.Pipelines Denial of Service.\" This affects .NET Core 2.1, System.IO.Pipelines, ASP.NET Core 2.1.");
            Vulnerabilities.Add("<script>", "Script tags should not be included in C# code (unless it's a string literal). This could possibly be an attempt of cross site scripting");

            return Vulnerabilities;
        }

    }
}